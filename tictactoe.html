<!DOCTYPE html>
<html>
<head>
    <title>Tic-Tac-Toe Tutorial</title>
    <link rel="stylesheet" type="text/css" href="styles.css"> <!-- Link to your CSS file -->
</head>
<body>
    <header>
        <h1>Tic-Tac-Toe Test-Driven Development Tutorial</h1>
    </header>

    <nav>
        <!-- Navigation links if needed -->
    </nav>

    <main>
        <section>
            <h2>Introduction</h2>
            <p>
                Welcome to the Tic-Tac-Toe Test-Driven Development (TDD) Tutorial! In this tutorial, we'll embark on a journey of building a Tic-Tac-Toe game using the principles of Test-Driven Development.
                TDD is a powerful approach to software development that emphasizes writing tests before writing the actual code. By following this approach, we ensure that our code is well-tested and reliable, which is crucial for creating robust applications.
            </p>
            <p>
                Throughout this tutorial, we'll go step by step, from setting up the project to implementing the game logic, all while adhering to the TDD methodology. You'll witness firsthand how tests guide our development process, leading to well-structured and thoroughly tested code.
            </p>
            <p>
               Whether you're new to TDD or an experienced developer looking to apply it in a practical scenario, this tutorial will provide you with valuable insights into both TDD and game development. By the end of this journey, you'll have not only a working Tic-Tac-Toe game but also a solid understanding of how TDD can enhance your development workflow. 
            </p>
            <p>
                Let's get started by setting up our project and laying the foundation for our Tic-Tac-Toe game. Get ready to code, test, and play!
            </p>
        </section>

        <!-- Within the <main> section of tictactoe.html -->

<section>
    <h2>Playing the First Move</h2>
    <p>
        In this section, we'll begin our journey by writing our very first test. We'll focus on allowing players to make the first move and placing "X" in the chosen cell. Let's dive into the process of writing a test and making it pass!
    </p>

    <h3>Writing the First Test</h3>
    <p>
        The first step is to create a test that checks whether players can place an "X" in the chosen cell when making the first move.
    </p>

    <pre><code class="language-java">
import org.junit.jupiter.api.Test;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.equalTo;

public class GameBrainTests {
    @Test
    void whenPlayingFirstMoveThenXAppearsToTheCell() {
        Game game = new Game();

        game.playMove(0);

        assertThat(game.getCell(0), equalTo("X"));
    }
}
    </code></pre>

    <h3>Implementing the Functionality</h3>
    <p>
        Now that we have our test in place, it's time for a challenge! Go ahead and try to implement the functionality yourself to make the test pass. You can use the provided test as a guide, and feel free to experiment with your code.
    </p>

    <p>
        Your task is to create the <code>Game</code> class with the necessary methods to allow players to place their moves and check the cells. Use your programming skills to make the test pass and see "X" appear in the chosen cell.
    </p>

    <p>
        Remember, Test-Driven Development encourages an iterative process of writing tests, implementing code, and refining. Don't hesitate to experiment and iterate until your test passes successfully!
    </p>

    <p>
        Once you've given it a try, you can compare your solution with the provided implementation below.
    </p>

<details>
        <summary>Click to view the provided implementation</summary>
        <pre><code class="language-java">
import java.util.ArrayList;
import java.util.List;

public class Game {
    private final List<String> boardState;
    private String activePlayer = "X";

    public Game() {
        this.boardState = new ArrayList<>();
        for (int i = 0; i < 9; i++) {
            boardState.add(" ");
        }
    }

    public void playMove(int cell) {
        boardState.set(cell, activePlayer);
    }

    public String getCell(int cell) {
        return boardState.get(cell);
    }
}
        </code></pre>
    </details>

    <p>
        With the test successfully passing, we've taken our first step towards building our Tic-Tac-Toe game using Test-Driven Development!
    </p>
</section>

        <section>
        <h2>Switching Active Player</h2>
        <p>
            In this section, we'll explore the process of switching the active player when making moves in our
            Tic-Tac-Toe game. We'll write a test to ensure that the active player changes from "X" to "O" after the
            first move is made.
        </p>

        <h3>Writing the Test</h3>
        <p>
            Let's create a test that checks whether the active player switches to "O" after the second move is played.
        </p>

        <pre><code class="language-java">
import org.junit.jupiter.api.Test;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.equalTo;

public class GameBrainTests {
    // ... Previous tests ...

    @Test
    void whenPlayingSecondMoveThenOAppearsToTheCell() {
        Game game = new Game();

        game.playMove(0);
        game.playMove(1);

        assertThat(game.getCell(1), equalTo("O"));
    }
}
    </code></pre>

        <h3>Implementing the Functionality</h3>
        <p>
            Now that we have our test in place, it's time for another challenge! Go ahead and try to implement the
            functionality yourself to make the test pass. You can use the provided test as a guide, and feel free to
            experiment with your code.
        </p>

        <details>
            <summary>Click to view the provided implementation</summary>
            <pre><code class="language-java">
import java.util.ArrayList;
import java.util.List;

public class Game {
    private final List<String> boardState;
    private String activePlayer = "X";

    public Game() {
        this.boardState = new ArrayList<>();
        for (int i = 0; i < 9; i++) {
            boardState.add(" ");
        }
    }

    public void playMove(int cell) {
        boardState.set(cell, activePlayer);
        activePlayer = activePlayer.equals("X") ? "O" : "X";
    }

    public String getCell(int cell) {
        return boardState.get(cell);
    }
}

        </code></pre>
        </details>

        <p>
            With the test for switching the active player passing, our game is becoming more dynamic as we progress
            through Test-Driven Development!
        </p>
    </section>

    <section>
        <h2>Preventing Duplicate Moves</h2>
        <p>
            In this section, we'll tackle the challenge of preventing players from making two moves on the same cell in our Tic-Tac-Toe game. We'll write a test to ensure that attempting to make a move on an occupied cell results in an exception being thrown.
        </p>

        <h3>Writing the Test</h3>
        <p>
            Let's create a test that checks whether attempting to make a move on an occupied cell throws a <code>GameLogicException</code>.
        </p>

        <pre><code class="language-java">
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertThrows;

public class GameBrainTests {
    // ... Previous tests ...

    @Test
    void whenTryingToMakeMoveToAnOccupiedCellShouldThrowException() {
        Game game = new Game();

        game.playMove(0);

        assertThrows(GameLogicException.class, () -> game.playMove(0));
    }
}
    </code></pre>

        <h3>Implementing the Functionality</h3>
        <p>
            Now, let's implement the functionality to prevent players from making moves on occupied cells. We'll enhance the <code>Game</code> class to check whether the cell is already occupied before allowing a move to be played.
        </p>
        <p>
            Go ahead and try to implement the
            functionality yourself to make the test pass. You can use the provided test as a guide, and feel free to
            experiment with your code.
        </p>

        <details>
            <summary>Click to view the provided implementation</summary>
            First, let's create a new exception type in a separate file.
            <pre><code class="language-java">
package TicTacToe;

public class IllegalMoveException extends RuntimeException {
    public IllegalMoveException() {
        super();
    }

    public IllegalMoveException(String message) {
        super(message);
    }
}
        </code></pre>
            Then, in the playMove() method of the Game class, let's start using it.
        <pre><code class="language-java">
public void playMove(int cell) {
        if (!boardState.get(cell).equals(" ")) {
            throw new IllegalMoveException("Invalid move. Cell is not empty.");
        }
        boardState.set(cell, activePlayer);
        activePlayer = activePlayer.equals("X") ? "O" : "X";
    }
        </code></pre>
        </details>

        <!-- ... Implementation code goes here ... -->

        <p>
            With the test for preventing duplicate moves in place, we're adding more depth to our game's logic through Test-Driven Development!
        </p>
    </section>

        <!-- Within the <main> section of tictactoe.html -->

<section>
    <h2>Preventing Out of Bounds Moves</h2>
    <p>
        In this section, we'll address the scenario where players attempt to make a move to a cell that is outside the bounds of the game board. We'll write a test to ensure that attempting such a move results in an exception being thrown.
    </p>

    <h3>Writing the Test</h3>
    <p>
        Let's create a test that checks whether attempting to make a move to a cell outside the bounds of the board throws an <code>IllegalMoveException</code>.
    </p>

    <pre><code class="language-java">
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.is;

public class GameBrainTests {
    // ... Previous tests ...

    @Test
    void whenTryingToMakeMoveToCellBiggerThanBoardShouldThrowException() {
        Game game = new Game();

        IllegalMoveException illegalMoveException = assertThrows(IllegalMoveException.class, () -> game.playMove(10));
        assertThat(illegalMoveException.getMessage(), is("Invalid move. Cell 10 is out of bounds."));
    }
}
    </code></pre>

    <h3>Implementing the Functionality</h3>
    <p>
        Now, let's implement the functionality to prevent players from making moves to cells that are out of bounds. We'll enhance the <code>Game</code> class to check whether the cell index is valid before allowing a move to be played.
    </p>

    <details>
        <summary>Click to view the provided implementation</summary>
        <pre><code class="language-java">
public void playMove(int cell) {
    if (cell > 9) {
        throw new IllegalMoveException(String.format("Invalid move. Cell %s is out of bounds.", cell));
    }
    if (!boardState.get(cell).equals(" ")) {
        throw new IllegalMoveException("Invalid move. Cell is not empty.");
    }
    boardState.set(cell, activePlayer);
    activePlayer = activePlayer.equals("X") ? "O" : "X";
}
        </code></pre>
    </details>

    <p>
        With the test for preventing out of bounds moves in place, our game's logic becomes even more robust as we continue the Test-Driven Development process!
    </p>
</section>

<!-- Within the <main> section of tictactoe.html -->

<section>
    <h2>Determining the Winner</h2>
    <p>
        In this section, we'll focus on the exciting moment when a player wins the game by getting three in a row. We'll write a test to ensure that the game correctly determines the winner when a player achieves this milestone.
    </p>

    <h3>Writing the Test</h3>
    <p>
        Let's create a test that checks whether the game correctly identifies the winner when a player has three in a row.
    </p>

    <pre><code class="language-java">
import org.junit.jupiter.api.Test;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.is;

public class GameBrainTests {
    // ... Previous tests ...

    @Test
    void whenPlayerHasThreeInARowThenGameShouldBeOver() {
        Game game = new Game();

        game.playMove(0);
        game.playMove(5);
        game.playMove(1);
        game.playMove(6);
        game.playMove(2);

        assertThat(game.getWinner(), is("X"));
    }
}
    </code></pre>

    <h3>Implementing the Functionality</h3>
    <p>
        Now, let's implement the functionality to determine the winner of the game. We'll enhance the <code>Game</code> class to check for a winning combination after each move and return the winning player if applicable.
    </p>

    <details>
        <summary>Click to view the provided implementation</summary>
        <pre><code class="language-java">
public String getWinner() {
    List<List<Integer>> winningCombinations = List.of(
        List.of(0, 1, 2),
        List.of(3, 4, 5),
        List.of(6, 7, 8),
        List.of(0, 3, 6),
        List.of(1, 4, 7),
        List.of(2, 5, 8),
        List.of(0, 4, 8),
        List.of(2, 4, 6)
    );
    String winner = null;
    for (List<Integer> combination : winningCombinations) {
        List<String> players = List.of(X, O);
        for (String player : players) {
            if (combination.stream().allMatch(i ->
                    getCell(i).equals(player))) {
                winner = player;
                break;
            }
        }
    }
    return winner;
}
        </code></pre>
    </details>

    <p>
        With the test for determining the winner in place, our game's logic is nearing completion as we progress through Test-Driven Development!
    </p>
</section>


        <!-- Other sections of the tutorial will go here -->
        <!-- You can add each section with explanations and code snippets -->
    </main>

    <footer>
        <p>&copy; 2023 TDDGameCoder</p>
    </footer>
</body>
</html>
